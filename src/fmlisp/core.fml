(ns ^{:doc "The core FMLisp language."
      :author "Elia Scotto"}
 fmlisp.core)

(def
  ^{:arglists '([message])
    :doc "Creates a new error with `message` as cause."
    :added "1.0"}
  error fmlisp.lang/error)

(def
  ^{:arglists '([& items])
    :doc "Creates a new list containing the items."
    :added "1.0"}
  list fmlisp.lang/list)

(def
  ^{:arglists '([x seq])
    :doc "Returns a new seq where x is the first element and seq is the rest."
    :added "1.0"
    :static true}
  cons fmlisp.lang/cons)

;; ========= Temp macros

(def
  ^{:macro true
    :added "1.0"}
  let (fn* let [& decl] (cons 'let* decl)))

(def
  ^{:macro true
    :added "1.0"}
  loop (fn* loop [& decl] (cons 'loop* decl)))

(def
  ^{:macro true
    :added "1.0"}
  fn (fn* fn [& decl] (cons 'fn* decl)))

(def
  ^{:arglists '([coll])
    :doc "Returns the first item in the collection.
    If coll is nil, returns nil."
    :added "1.0"
    :static true}
  first fmlisp.lang/first)

(def
  ^{:arglists '([coll])
    :doc "Same as (first (next x))"
    :added "1.0"}
  second fmlisp.lang/second)

(def
  ^{:arglists '([coll])
    :tag clojure.lang.ISeq
    :doc "Returns a seq of the items after the first.
    If there are no more items, returns nil."
    :added "1.0"}
  next fmlisp.lang/next)

(def
  ^{:arglists '([coll])
    :tag clojure.lang.ISeq
    :doc "Returns a possibly empty seq of the items after the first."
    :added "1.0"}
  rest fmlisp.lang/rest)

(def
  ^{:doc "Same as (first (first x))"
    :arglists '([x])
    :added "1.0"}
  ffirst (fn ffirst [x] (first (first x))))

(def
  ^{:doc "Same as (next (first x))"
    :arglists '([x])
    :added "1.0"}
  nfirst (fn nfirst [x] (next (first x))))

(def
  ^{:doc "Same as (first (next x))"
    :arglists '([x])
    :added "1.0"}
  fnext (fn fnext [x] (first (next x))))

(def
  ^{:doc "Same as (next (next x))"
    :arglists '([x])
    :added "1.0"}
  nnext (fn nnext [x] (next (next x))))

(def
  ^{:arglists '([] [coll] [coll x] [coll x & xs])
    :doc "conj[oin]. Returns a new collection with the xs
    'added'. (conj nil item) returns (item).
    (conj coll) returns coll. (conj) returns [].
    The 'addition' may happen at different 'places' depending
    on the concrete type."
    :added "1.0"}
  conj fmlisp.lang/conj)

(def
  ^{:arglists '(^clojure.lang.ISeq [coll])
    :doc "Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings, native Java arrays (of reference types) and any objects
    that implement Iterable. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object."
    :tag clojure.lang.ISeq
    :added "1.0"
    :static true}
  seq fmlisp.lang/seq)

(def
  ^{:arglists '([t x])
    :doc "Evaluates `x` and tests if it is a value of type `t`.
    Returns `true` or `false`"
    :added "1.0"}
  is? fmlisp.lang/is?)

(def
  ^{:arglists '([message])
    :doc "Creates a new error with a message."
    :added "1.0"}
  error fmlisp.lang/error)

(def
  ^{:arglists '([x])
    :doc "Return true if x is a Character"
    :added "1.0"
    :static true}
  char? fmlisp.lang/char?)

(def
  ^{:arglists '([x])
    :doc "Return true if x is a String"
    :added "1.0"
    :static true}
  string? fmlisp.lang/string?)

(def
  ^{:arglists '([x])
    :doc "Return true if x implements a HashMap"
    :added "1.0"
    :static true}
  map? fmlisp.lang/map?)

(def
  ^{:arglists '([x])
    :doc "Return true if x implements a Vector"
    :added "1.0"
    :static true}
  vector? fmlisp.lang/vector?)

(def
  ^{:arglists '([coll])
    :doc "Return the last item in coll"
    :added "1.0"}
  last fmlisp.lang/last)

(def
  ^{:arglists '([coll])
    :doc "Return a seq of all but the last item in coll, in linear time"
    :added "1.0"
    :static true}
  butlast fmlisp.lang/butlast)

(def
  ^{:arglists '([map key val] [map key val & kvs])
    :doc "assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be <= (count vector)."
    :added "1.0"
    :static true}
  assoc
  (fn ^:static assoc
    ([map key val] (fmlisp.lang/assoc map key val))
    ([map key val & kvs]
     (let [ret (fmlisp.lang/assoc map key val)]
       (if kvs
         (if (next kvs)
           (assoc ret (first kvs) (second kvs) (nnext kvs))
           (throw (error "assoc expects even number of arguments after map/vector, found odd number")))
         ret)))))

;; metadata

(def
  ^{:arglists '([x])
    :doc "Returns the metadata of `x`, returns nil if there is no metadata."
    :added "1.0"
    :static true}
  meta fmlisp.lang/meta)

(def
  ^{:arglists '([x m])
    :doc "Returns an object of the same type and value as `x`, with
    map m as its metadata."
    :added "1.0"
    :static true}
  with-meta fmlisp.lang/with-meta)

(def ^{:private true :dynamic true}
  assert-valid-fdecl (fn [fdecl]))

(def
  ^{:private true}
  sigs
  (fn [fdecl]
    (assert-valid-fdecl fdecl)
    (let [asig
          (fn [fdecl]
            (let [arglist (first fdecl)
                 ;elide implicit macro args
                  arglist (if (fmlisp.lang/= '&form (first arglist))
                            (fmlisp.lang/subvec arglist 2 (fmlisp.lang/count arglist))
                            arglist)
                  body (next fdecl)]
              (if (map? (first body))
                (if (next body)
                  (with-meta arglist (conj (if (meta arglist) (meta arglist) {}) (first body)))
                  arglist)
                arglist)))]
      (if (seq? (first fdecl))
        (loop [ret [] fdecls fdecl]
          (if fdecls
            (sigs (conj ret (asig (first fdecls))) (next fdecls))
            (seq ret)))
        (list (asig fdecl))))))
