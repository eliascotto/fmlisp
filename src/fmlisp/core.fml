(ns ^{:doc "The core FMLisp language."
      :author "Elia Scotto"}
 fmlisp.core)

(def
  ^{:arglists '([message])
    :doc "Creates a new error with `message` as cause."
    :added "1.0"}
  error fmlisp.lang/error)

(def
  ^{:arglists '([& items])
    :doc "Creates a new list containing the items."
    :added "1.0"}
  list fmlisp.lang/list)

(def
  ^{:arglists '([x seq])
    :doc "Returns a new seq where x is the first element and seq is the rest."
    :added "1.0"
    :static true}
  cons fmlisp.lang/cons)

(def
  ^{:arglists '([coll])
    :doc "Creates a new vector containing the contents of coll."
    :added "1.0"}
  vec fmlisp.lang/vec)

(def
  ^{:arglists '([coll])
    :doc "Creates a new vector containing the contents of coll."
    :added "1.0"}
  concat fmlisp.lang/concat)

;; ========= Temp macros

(def
  ^{:macro true
    :added "1.0"}
  let (fn* let [& decl] (cons 'let* decl)))

(def
  ^{:macro true
    :added "1.0"}
  loop (fn* loop [& decl] (cons 'loop* decl)))

(def
  ^{:macro true
    :added "1.0"}
  fn (fn* fn [& decl] (cons 'fn* decl)))

(def
  ^{:arglists '([coll])
    :doc "Returns the first item in the collection.
    If coll is nil, returns nil."
    :added "1.0"
    :static true}
  first fmlisp.lang/first)

(def
  ^{:arglists '([coll])
    :doc "Same as (first (next x))"
    :added "1.0"}
  second fmlisp.lang/second)

(def
  ^{:arglists '([coll])
    :doc "Returns a seq of the items after the first.
    If there are no more items, returns nil."
    :added "1.0"}
  next fmlisp.lang/next)

(def
  ^{:arglists '([coll])
    :tag clojure.lang.ISeq
    :doc "Returns a possibly empty seq of the items after the first."
    :added "1.0"}
  rest fmlisp.lang/rest)

(def
  ^{:doc "Same as (first (first x))"
    :arglists '([x])
    :added "1.0"}
  ffirst (fn ffirst [x] (first (first x))))

(def
  ^{:doc "Same as (next (first x))"
    :arglists '([x])
    :added "1.0"}
  nfirst (fn nfirst [x] (next (first x))))

(def
  ^{:doc "Same as (first (next x))"
    :arglists '([x])
    :added "1.0"}
  fnext (fn fnext [x] (first (next x))))

(def
  ^{:doc "Same as (next (next x))"
    :arglists '([x])
    :added "1.0"}
  nnext (fn nnext [x] (next (next x))))

(def
  ^{:arglists '([] [coll] [coll x] [coll x & xs])
    :doc "conj[oin]. Returns a new collection with the xs
    'added'. (conj nil item) returns (item).
    (conj coll) returns coll. (conj) returns [].
    The 'addition' may happen at different 'places' depending
    on the concrete type."
    :added "1.0"}
  conj fmlisp.lang/conj)

(def
  ^{:arglists '([coll])
    :doc "Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object."
    :added "1.0"
    :static true}
  seq fmlisp.lang/seq)

(def
  ^{:arglists '([coll])
    :doc "Returns a seq on the collection. If the collection is
    empty, returns nil.  (seq nil) returns nil. seq also works on
    Strings. Note that seqs cache values, thus seq
    should not be used on any Iterable whose iterator repeatedly
    returns the same mutable object."
    :added "1.0"
    :static true}
  seq? fmlisp.lang/seq?)

(def
  ^{:arglists '([t x])
    :doc "Evaluates `x` and tests if it is a value of type `t`.
    Returns `true` or `false`"
    :added "1.0"}
  is? fmlisp.lang/is?)

(def
  ^{:arglists '([message])
    :doc "Creates a new error with a message."
    :added "1.0"}
  error fmlisp.lang/error)

(def
  ^{:arglists '([x])
    :doc "Return true if x is a Character"
    :added "1.0"
    :static true}
  char? fmlisp.lang/char?)

(def
  ^{:arglists '([x])
    :doc "Return true if x is a String"
    :added "1.0"
    :static true}
  string? fmlisp.lang/string?)

(def
  ^{:arglists '([x])
    :doc "Return true if x implements a HashMap"
    :added "1.0"
    :static true}
  map? fmlisp.lang/map?)

(def
  ^{:arglists '([x])
    :doc "Return true if x implements a Vector"
    :added "1.0"
    :static true}
  vector? fmlisp.lang/vector?)

(def
  ^{:arglists '([coll])
    :doc "Return the last item in coll"
    :added "1.0"}
  last fmlisp.lang/last)

(def
  ^{:arglists '([coll])
    :doc "Return a seq of all but the last item in coll, in linear time"
    :added "1.0"
    :static true}
  butlast fmlisp.lang/butlast)

(def
  ^{:arglists '([map key val] [map key val & kvs])
    :doc "assoc[iate]. When applied to a map, returns a new map of the
    same (hashed/sorted) type, that contains the mapping of key(s) to
    val(s). When applied to a vector, returns a new vector that
    contains val at index. Note - index must be <= (count vector)."
    :added "1.0"
    :static true}
  assoc
  (fn ^:static assoc
    ([map key val] (fmlisp.lang/assoc map key val))
    ([map key val & kvs]
     (let [ret (fmlisp.lang/assoc map key val)]
       (if kvs
         (if (next kvs)
           (assoc ret (first kvs) (second kvs) (nnext kvs))
           (throw (error "assoc expects even number of arguments after map/vector, found odd number")))
         ret)))))

;; metadata

(def
  ^{:arglists '([x])
    :doc "Returns the metadata of `x`, returns nil if there is no metadata."
    :added "1.0"
    :static true}
  meta fmlisp.lang/meta)

(def
  ^{:arglists '([x m])
    :doc "Returns an object of the same type and value as `x`, with
    map m as its metadata."
    :added "1.0"
    :static true}
  with-meta fmlisp.lang/with-meta)

(def println fmlisp.lang/println)

(def ^{:private true :dynamic true}
  assert-valid-fdecl (fn [fdecl]))

(def
  ^{:private true}
  sigs
  (fn [fdecl]
    (assert-valid-fdecl fdecl)
    (let [asig
          (fn [fdecl]
            (let [arglist (first fdecl)
                 ;elide implicit macro args
                  arglist (if (fmlisp.lang/= '&form (first arglist))
                            (fmlisp.lang/subvec arglist 2 (fmlisp.lang/count arglist))
                            arglist)
                  body (next fdecl)]
              (if (map? (first body))
                (if (next body)
                  (with-meta arglist (conj (if (meta arglist) (meta arglist) {}) (first body)))
                  arglist)
                arglist)))]
      (if (seq? (first fdecl))
        (loop [ret [] fdecls fdecl]
          (if fdecls
            (do
              (recur (conj ret (asig (first fdecls))) (next fdecls)))
            (seq ret)))
        (list (asig fdecl))))))

(def

  ^{:doc "Same as (def name (fn [params* ] exprs*)) or (def
    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added
    to the var metadata. prepost-map defines a map with optional keys
    :pre and :post that contain collections of pre or post conditions."
    :arglists '([name doc-string? attr-map? [params*] prepost-map? body]
                [name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?])
    :macro true
    :added "1.0"}
  defn (fn defn [name & fdecl]
        ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)
         (if (is? 'Symbol name)
           nil
           (throw (error "First argument to defn must be a symbol")))
         (let [m (if (string? (first fdecl))
                   {:doc (first fdecl)}
                   {})
               fdecl (if (string? (first fdecl))
                       (next fdecl)
                       fdecl)
               m (if (map? (first fdecl))
                   (conj m (first fdecl))
                   m)
               fdecl (if (map? (first fdecl))
                       (next fdecl)
                       fdecl)
               fdecl (if (vector? (first fdecl))
                       (list fdecl)
                       fdecl)
               m (if (map? (last fdecl))
                   (conj m (last fdecl))
                   m)
               fdecl (if (map? (last fdecl))
                       (butlast fdecl)
                       fdecl)
               m (conj {:arglists (list 'quote (sigs fdecl))} m)
               m (let [inline (:inline m)
                       ifn (first inline)
                       iname (second inline)]
                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)
                   (if (if (fmlisp.lang/= 'fn ifn)
                         (if (is? 'Symbol iname) false true))
                    ;; inserts the same fn name to the inline fn if it does not have one
                     (assoc m :inline (cons ifn (cons (fmlisp.lang/intern (fmlisp.lang/concat-str (fmlisp.lang/get-name name) "__inliner"))
                                                      (next inline))))
                     m))
               m (conj (if (meta name) (meta name) {}) m)]
           (list 'def (with-meta name m)
                ;;todo - restore propagation of fn name
                ;;must figure out how to convey primitive hints to self calls first
								;;(cons `fn fdecl)
                 (with-meta (cons `fn fdecl) {:rettag (:tag m)})))))

(def vector
  "Creates a new vector containing the args."
  {:added "1.0"
   :static true}
  fmlisp.lang/vector)

(defn vec
  "Creates a new vector containing the contents of coll."
  {:added "1.0"
   :static true}
  ([coll]
   (fmlisp.lang/vec coll)))

(defn hash-map
  "keyval => key val
  Returns a new hash map with supplied mappings. If any keys are
  equal, they are handled as if by repeated uses of assoc."
  {:added "1.0"
   :static true}
  ([] {})
  ([& keyvals]
   (fmlisp.lang/hash-map keyvals)))

(defn hash-set
  "Returns a new hash set with supplied keys. Any equal keys are
  handled as if by repeated uses of conj."
  {:added "1.0"
   :static true}
  ([] #{})
  ([& keys]
   (fmlisp.lang/hash-set keyvals)))

(defn sorted-map
  "keyval => key val
  Returns a new sorted map with supplied mappings.  If any keys are
  equal, they are handled as if by repeated uses of assoc."
  {:added "1.0"
   :static true}
  ([& keyvals]
   (fmlisp.lang/sorted-map keyvals)))

(defn sorted-set
  "Returns a new sorted set with supplied keys.  Any equal keys are
  handled as if by repeated uses of conj."
  {:added "1.0"
   :static true}
  ([& keys]
   (fmlisp.lang/sorted-set keys)))

(defn nil?
  "Returns true if x is nil, false otherwise."
  {:tag Boolean
   :added "1.0"
   :static true
   :inline (fn [x] (list 'fmlisp.lang/nil? x))
   }
  [x] (fmlisp.lang/nil? x))

(def

 ^{:doc "Like defn, but the resulting function name is declared as a
  macro and will be used as a macro by the compiler when it is
  called."
   :arglists '([name doc-string? attr-map? [params*] body]
               [name doc-string? attr-map? ([params*] body)+ attr-map?])
   :macro true
   :added "1.0"}
 defmacro (fn [name & args]
             (let [prefix (loop [p (list name) args args]
                            (let [f (first args)]
                              (if (string? f)
                                (recur (cons f p) (next args))
                                (if (map? f)
                                  (recur (cons f p) (next args))
                                  p))))
                   fdecl (loop [fd args]
                           (if (string? (first fd))
                             (recur (next fd))
                             (if (map? (first fd))
                               (recur (next fd))
                               fd)))
                   fdecl (if (vector? (first fdecl))
                           (list fdecl)
                           fdecl)
                   add-implicit-args (fn [fd]
                             (let [args (first fd)]
                               (cons (vec args) (next fd))))
                   add-args (fn [acc ds]
                              (if (nil? ds)
                                acc
                                (let [d (first ds)]
                                  (if (map? d)
                                    (conj acc d)
                                    (add-args (conj acc (add-implicit-args d)) (next ds))))))
                   fdecl (seq (add-args [] fdecl))
                   decl (loop [p prefix d fdecl]
                          (if p
                            (recur (next p) (cons (first p) d))
                            d))]
               (list 'do
                     (cons `defn decl)
                     (list 'set-macro (list 'var name))
                     (list 'var name)))))

(defmacro when
  "Evaluates test. If logical true, evaluates body in an implicit do."
  {:added "1.0"}
  [test & body]
  (list 'if test (cons 'do body)))
